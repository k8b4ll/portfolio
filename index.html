<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Portfolio Landing</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="page">
      <header>
        <div class="header-left">
          <div>Katelyn Moro</div>
          <div>Graphic &amp; Digital Design</div>
        </div>
       <!-- <div class="header-center">
          <div>insert email here</div>
        </div> --> <!-- place holder -->
        <div class="header-right">
          <div>About</div>
        </div>
      </header>
      <main>
  <div
    class="selected selected-anchor"
    data-line1="Selected Projects"
    data-line2="2020 — 2025"
    aria-label="Selected Projects 2020 — 2025"
  ></div>
</main>
      <footer>
        <div class="footer-left">
          <div>1/7</div>
          <div>
            Rokinon<br />
            Brand Identity
          </div>
        </div>
        <div class="footer-center">Project info</div>
        <div class="footer-right">
          Scope
          <div class="scope">
            brand visuals, web / product pages, art direction, print, digital, motion,
            campaign, social + e-commerce assets
          </div>
        </div>
      </footer>
    </div>
    <canvas id="inkCanvas"></canvas>
   <script>
(() => {
  const canvas = document.getElementById("inkCanvas");
  const ctx = canvas.getContext("2d");

  const anchor = document.querySelector(".selected-anchor");
  const footer = document.querySelector("footer");

  const settings = {
    count: 2200,      // more dots = clearer type
    r: 0.7,           // TINY particles
    floatSpeed: 0.55,
    wander: 0.10,
    pull: 0.09,
    damp: 0.86,
    rehideMs: 5000
  };

  let particles = [];
  let formed = false;
  let revertTimer = null;

  function getOverlayHeight() {
    if (!footer) return window.innerHeight;
    const top = footer.getBoundingClientRect().top;
    // canvas should stop at the black divider line (footer top border)
    return Math.max(200, Math.floor(top));
  }

  function resizeCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const h = getOverlayHeight();
    canvas.style.height = h + "px";
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function buildParticles() {
    const w = window.innerWidth;
    const h = getOverlayHeight();
    particles = Array.from({ length: settings.count }, () => ({
      x: Math.random() * w,
      y: Math.random() * h,
      vx: (Math.random() - 0.5) * 0.7,
      vy: (Math.random() - 0.5) * 0.7,
      tx: null,
      ty: null
    }));
  }

  // Build targets ONLY inside the anchor box, but translate them into page coords
  function computeTargets() {
    if (!anchor) return [];
    const ar = anchor.getBoundingClientRect();

    // Offscreen canvas sized to anchor box
    const off = document.createElement("canvas");
    off.width = Math.max(1, Math.floor(ar.width));
    off.height = Math.max(1, Math.floor(ar.height));
    const o = off.getContext("2d");

    const line1 = anchor.dataset.line1 || "";
    const line2 = anchor.dataset.line2 || "";

    // Helvetica on reveal (this affects the particle-formed text)
    const fs = Math.max(14, Math.min(22, ar.width * 0.05));
    o.clearRect(0, 0, off.width, off.height);
    o.fillStyle = "#000";
    o.textBaseline = "top";
    o.textAlign = "left";
    o.font = `600 ${fs}px Helvetica Neue, Helvetica, Arial, sans-serif`;
    o.fillText(line1, 0, 18);
    o.fillText(line2, 0, 18 + fs + 10);

    const img = o.getImageData(0, 0, off.width, off.height).data;

    const step = Math.max(2, Math.floor(Math.min(ar.width, ar.height) / 60)); // denser sampling
    const pts = [];

    for (let y = 0; y < off.height; y += step) {
      for (let x = 0; x < off.width; x += step) {
        const i = (y * off.width + x) * 4;
        if (img[i + 3] > 20) {
          // translate into global page coords
          pts.push({ x: ar.left + x, y: ar.top + y });
        }
      }
    }

    if (!pts.length) return [];
    const out = [];
    for (let i = 0; i < settings.count; i++) {
      out.push(pts[(Math.random() * pts.length) | 0]);
    }
    return out;
  }

  function reveal() {
    formed = true;
    const targets = computeTargets();
    for (let i = 0; i < particles.length; i++) {
      const t = targets[i];
      particles[i].tx = t ? t.x : particles[i].x;
      particles[i].ty = t ? t.y : particles[i].y;
    }
    clearTimeout(revertTimer);
    revertTimer = setTimeout(hide, settings.rehideMs);
  }

  function hide() {
    formed = false;
    for (const p of particles) {
      p.tx = null;
      p.ty = null;
    }
    clearTimeout(revertTimer);
    revertTimer = null;
  }

  function tick() {
    const w = window.innerWidth;
    const h = getOverlayHeight();

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "#000";

    for (const p of particles) {
      if (formed && p.tx != null) {
        const dx = p.tx - p.x;
        const dy = p.ty - p.y;
        p.vx = p.vx * settings.damp + dx * settings.pull;
        p.vy = p.vy * settings.damp + dy * settings.pull;
        p.x += p.vx;
        p.y += p.vy;
      } else {
        p.vx += (Math.random() - 0.5) * settings.wander;
        p.vy += (Math.random() - 0.5) * settings.wander;

        const m = settings.floatSpeed;
        p.vx = Math.max(-m, Math.min(m, p.vx));
        p.vy = Math.max(-m, Math.min(m, p.vy));

        p.x += p.vx;
        p.y += p.vy;

        if (p.x < 0 || p.x > w) p.vx *= -1;
        if (p.y < 0 || p.y > h) p.vy *= -1;

        p.x = Math.min(Math.max(p.x, 0), w);
        p.y = Math.min(Math.max(p.y, 0), h);
      }

      ctx.beginPath();
      ctx.arc(p.x, p.y, settings.r, 0, Math.PI * 2);
      ctx.fill();
    }

    requestAnimationFrame(tick);
  }

  // Reveal only when mouse crosses center X axis
  function handlePointerMove(e) {
    const cx = window.innerWidth / 2;
    if (e.clientX >= cx) {
      // If already formed, let it stay until timer hides it
      if (!formed) reveal();
    } else {
      // If they move back left, we can hide immediately (optional)
      // hide();
    }
  }

  window.addEventListener("pointermove", handlePointerMove, { passive: true });
  window.addEventListener("pointerdown", handlePointerMove, { passive: true });

  window.addEventListener("resize", () => {
    resizeCanvas();
    buildParticles();
    if (formed) reveal();
  });

  // Init
  resizeCanvas();
  buildParticles();
  tick();
})();
</script>

  </body>
</html>
